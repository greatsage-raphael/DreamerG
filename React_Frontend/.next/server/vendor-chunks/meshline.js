"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/meshline";
exports.ids = ["vendor-chunks/meshline"];
exports.modules = {

/***/ "(ssr)/./node_modules/meshline/dist/index.cjs":
/*!**********************************************!*\
  !*** ./node_modules/meshline/dist/index.cjs ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nObject.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: \"Module\" } });\nconst THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\nfunction _interopNamespace(e) {\n  if (e && e.__esModule)\n    return e;\n  const n = Object.create(null, { [Symbol.toStringTag]: { value: \"Module\" } });\n  if (e) {\n    for (const k in e) {\n      if (k !== \"default\") {\n        const d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: () => e[k]\n        });\n      }\n    }\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\nconst THREE__namespace = /* @__PURE__ */ _interopNamespace(THREE);\nfunction memcpy(src, srcOffset, dst, dstOffset, length) {\n  let i;\n  src = src.subarray || src.slice ? src : src.buffer;\n  dst = dst.subarray || dst.slice ? dst : dst.buffer;\n  src = srcOffset ? src.subarray ? src.subarray(srcOffset, length && srcOffset + length) : src.slice(srcOffset, length && srcOffset + length) : src;\n  if (dst.set) {\n    dst.set(src, dstOffset);\n  } else {\n    for (i = 0; i < src.length; i++)\n      dst[i + dstOffset] = src[i];\n  }\n  return dst;\n}\nfunction convertPoints(points) {\n  if (points instanceof Float32Array)\n    return points;\n  if (points instanceof THREE__namespace.BufferGeometry)\n    return points.getAttribute(\"position\").array;\n  return points.map((p) => {\n    const isArray = Array.isArray(p);\n    return p instanceof THREE__namespace.Vector3 ? [p.x, p.y, p.z] : p instanceof THREE__namespace.Vector2 ? [p.x, p.y, 0] : isArray && p.length === 3 ? [p[0], p[1], p[2]] : isArray && p.length === 2 ? [p[0], p[1], 0] : p;\n  }).flat();\n}\nclass MeshLineGeometry extends THREE__namespace.BufferGeometry {\n  constructor() {\n    super();\n    __publicField(this, \"type\", \"MeshLine\");\n    __publicField(this, \"isMeshLine\", true);\n    __publicField(this, \"positions\", []);\n    __publicField(this, \"previous\", []);\n    __publicField(this, \"next\", []);\n    __publicField(this, \"side\", []);\n    __publicField(this, \"width\", []);\n    __publicField(this, \"indices_array\", []);\n    __publicField(this, \"uvs\", []);\n    __publicField(this, \"counters\", []);\n    __publicField(this, \"widthCallback\", null);\n    __publicField(this, \"_attributes\");\n    __publicField(this, \"_points\", []);\n    __publicField(this, \"points\");\n    __publicField(this, \"matrixWorld\", new THREE__namespace.Matrix4());\n    Object.defineProperties(this, {\n      points: {\n        enumerable: true,\n        get() {\n          return this._points;\n        },\n        set(value) {\n          this.setPoints(value, this.widthCallback);\n        }\n      }\n    });\n  }\n  setMatrixWorld(matrixWorld) {\n    this.matrixWorld = matrixWorld;\n  }\n  setPoints(points, wcb) {\n    points = convertPoints(points);\n    this._points = points;\n    this.widthCallback = wcb != null ? wcb : null;\n    this.positions = [];\n    this.counters = [];\n    if (points.length && points[0] instanceof THREE__namespace.Vector3) {\n      for (let j = 0; j < points.length; j++) {\n        const p = points[j];\n        const c = j / (points.length - 1);\n        this.positions.push(p.x, p.y, p.z);\n        this.positions.push(p.x, p.y, p.z);\n        this.counters.push(c);\n        this.counters.push(c);\n      }\n    } else {\n      for (let j = 0; j < points.length; j += 3) {\n        const c = j / (points.length - 1);\n        this.positions.push(points[j], points[j + 1], points[j + 2]);\n        this.positions.push(points[j], points[j + 1], points[j + 2]);\n        this.counters.push(c);\n        this.counters.push(c);\n      }\n    }\n    this.process();\n  }\n  compareV3(a, b) {\n    const aa = a * 6;\n    const ab = b * 6;\n    return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];\n  }\n  copyV3(a) {\n    const aa = a * 6;\n    return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];\n  }\n  process() {\n    const l = this.positions.length / 6;\n    this.previous = [];\n    this.next = [];\n    this.side = [];\n    this.width = [];\n    this.indices_array = [];\n    this.uvs = [];\n    let w;\n    let v;\n    if (this.compareV3(0, l - 1)) {\n      v = this.copyV3(l - 2);\n    } else {\n      v = [\n        this.positions[0] - (this.positions[6] - this.positions[0]),\n        this.positions[1] - (this.positions[6 + 1] - this.positions[1]),\n        this.positions[2] - (this.positions[6 + 2] - this.positions[2])\n      ];\n    }\n    this.previous.push(v[0], v[1], v[2]);\n    this.previous.push(v[0], v[1], v[2]);\n    for (let j = 0; j < l; j++) {\n      this.side.push(1);\n      this.side.push(-1);\n      if (this.widthCallback)\n        w = this.widthCallback(j / (l - 1));\n      else\n        w = 1;\n      this.width.push(w);\n      this.width.push(w);\n      this.uvs.push(j / (l - 1), 0);\n      this.uvs.push(j / (l - 1), 1);\n      if (j < l - 1) {\n        v = this.copyV3(j);\n        this.previous.push(v[0], v[1], v[2]);\n        this.previous.push(v[0], v[1], v[2]);\n        const n = j * 2;\n        this.indices_array.push(n, n + 1, n + 2);\n        this.indices_array.push(n + 2, n + 1, n + 3);\n      }\n      if (j > 0) {\n        v = this.copyV3(j);\n        this.next.push(v[0], v[1], v[2]);\n        this.next.push(v[0], v[1], v[2]);\n      }\n    }\n    if (this.compareV3(l - 1, 0)) {\n      v = this.copyV3(1);\n    } else {\n      v = [\n        this.positions[l - 1] + (this.positions[l - 1] - this.positions[l - 1 - 6]),\n        this.positions[l - 2] + (this.positions[l - 2] - this.positions[l - 2 - 6]),\n        this.positions[l - 3] + (this.positions[l - 3] - this.positions[l - 3 - 6])\n      ];\n    }\n    this.next.push(v[0], v[1], v[2]);\n    this.next.push(v[0], v[1], v[2]);\n    if (!this._attributes || this._attributes.position.count !== this.counters.length) {\n      this._attributes = {\n        position: new THREE__namespace.BufferAttribute(new Float32Array(this.positions), 3),\n        previous: new THREE__namespace.BufferAttribute(new Float32Array(this.previous), 3),\n        next: new THREE__namespace.BufferAttribute(new Float32Array(this.next), 3),\n        side: new THREE__namespace.BufferAttribute(new Float32Array(this.side), 1),\n        width: new THREE__namespace.BufferAttribute(new Float32Array(this.width), 1),\n        uv: new THREE__namespace.BufferAttribute(new Float32Array(this.uvs), 2),\n        index: new THREE__namespace.BufferAttribute(new Uint16Array(this.indices_array), 1),\n        counters: new THREE__namespace.BufferAttribute(new Float32Array(this.counters), 1)\n      };\n    } else {\n      this._attributes.position.copyArray(new Float32Array(this.positions));\n      this._attributes.position.needsUpdate = true;\n      this._attributes.previous.copyArray(new Float32Array(this.previous));\n      this._attributes.previous.needsUpdate = true;\n      this._attributes.next.copyArray(new Float32Array(this.next));\n      this._attributes.next.needsUpdate = true;\n      this._attributes.side.copyArray(new Float32Array(this.side));\n      this._attributes.side.needsUpdate = true;\n      this._attributes.width.copyArray(new Float32Array(this.width));\n      this._attributes.width.needsUpdate = true;\n      this._attributes.uv.copyArray(new Float32Array(this.uvs));\n      this._attributes.uv.needsUpdate = true;\n      this._attributes.index.copyArray(new Uint16Array(this.indices_array));\n      this._attributes.index.needsUpdate = true;\n    }\n    this.setAttribute(\"position\", this._attributes.position);\n    this.setAttribute(\"previous\", this._attributes.previous);\n    this.setAttribute(\"next\", this._attributes.next);\n    this.setAttribute(\"side\", this._attributes.side);\n    this.setAttribute(\"width\", this._attributes.width);\n    this.setAttribute(\"uv\", this._attributes.uv);\n    this.setAttribute(\"counters\", this._attributes.counters);\n    this.setAttribute(\"position\", this._attributes.position);\n    this.setAttribute(\"previous\", this._attributes.previous);\n    this.setAttribute(\"next\", this._attributes.next);\n    this.setAttribute(\"side\", this._attributes.side);\n    this.setAttribute(\"width\", this._attributes.width);\n    this.setAttribute(\"uv\", this._attributes.uv);\n    this.setAttribute(\"counters\", this._attributes.counters);\n    this.setIndex(this._attributes.index);\n    this.computeBoundingSphere();\n    this.computeBoundingBox();\n  }\n  advance({ x, y, z }) {\n    const positions = this._attributes.position.array;\n    const previous = this._attributes.previous.array;\n    const next = this._attributes.next.array;\n    const l = positions.length;\n    memcpy(positions, 0, previous, 0, l);\n    memcpy(positions, 6, positions, 0, l - 6);\n    positions[l - 6] = x;\n    positions[l - 5] = y;\n    positions[l - 4] = z;\n    positions[l - 3] = x;\n    positions[l - 2] = y;\n    positions[l - 1] = z;\n    memcpy(positions, 6, next, 0, l - 6);\n    next[l - 6] = x;\n    next[l - 5] = y;\n    next[l - 4] = z;\n    next[l - 3] = x;\n    next[l - 2] = y;\n    next[l - 1] = z;\n    this._attributes.position.needsUpdate = true;\n    this._attributes.previous.needsUpdate = true;\n    this._attributes.next.needsUpdate = true;\n  }\n}\nconst vertexShader = `\n  #include <common>\n  #include <logdepthbuf_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n\n  attribute vec3 previous;\n  attribute vec3 next;\n  attribute float side;\n  attribute float width;\n  attribute float counters;\n  \n  uniform vec2 resolution;\n  uniform float lineWidth;\n  uniform vec3 color;\n  uniform float opacity;\n  uniform float sizeAttenuation;\n  \n  varying vec2 vUV;\n  varying vec4 vColor;\n  varying float vCounters;\n  \n  vec2 fix(vec4 i, float aspect) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n  \tvCounters = counters;\n    return res;\n  }\n  \n  void main() {\n    float aspect = resolution.x / resolution.y;\n    vColor = vec4(color, opacity);\n    vUV = uv;\n  \n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4(position, 1.0) * aspect;\n    vec4 prevPos = m * vec4(previous, 1.0);\n    vec4 nextPos = m * vec4(next, 1.0);\n  \n    vec2 currentP = fix(finalPosition, aspect);\n    vec2 prevP = fix(prevPos, aspect);\n    vec2 nextP = fix(nextPos, aspect);\n  \n    float w = lineWidth * width;\n  \n    vec2 dir1 = normalize(currentP - prevP);\n    vec2 dir2 = normalize(nextP - currentP);\n    vec2 dir = normalize(dir1 + dir2);\n\n    vec2 perp = vec2(-dir1.y, dir1.x);\n    vec2 miter = vec2(-dir.y, dir.x);\n    //w = clamp(w / dot(miter, perp), 0., 4. * lineWidth * width);\n  \n    //vec2 normal = (cross(vec3(dir, 0.), vec3(0., 0., 1.))).xy;\n    vec4 normal = vec4(-dir.y, dir.x, 0., 1.);\n    normal.xy *= .5 * w;\n    //normal *= projectionMatrix;\n    if (sizeAttenuation == 0.) {\n      normal.xy *= finalPosition.w;\n      normal.xy /= (vec4(resolution, 0., 1.) * projectionMatrix).xy * aspect;\n    }\n  \n    finalPosition.xy += normal.xy * side;\n    gl_Position = finalPosition;\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    #include <clipping_planes_vertex>\n    #include <fog_vertex>\n  }\n`;\nconst version = /* @__PURE__ */ (() => parseInt(THREE__namespace.REVISION.replace(/\\D+/g, \"\")))();\nconst colorspace_fragment = version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\";\nconst fragmentShader = `\n  #include <fog_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  uniform sampler2D map;\n  uniform sampler2D alphaMap;\n  uniform float useGradient;\n  uniform float useMap;\n  uniform float useAlphaMap;\n  uniform float useDash;\n  uniform float dashArray;\n  uniform float dashOffset;\n  uniform float dashRatio;\n  uniform float visibility;\n  uniform float alphaTest;\n  uniform vec2 repeat;\n  uniform vec3 gradient[2];\n  \n  varying vec2 vUV;\n  varying vec4 vColor;\n  varying float vCounters;\n  \n  void main() {\n    #include <logdepthbuf_fragment>\n    vec4 diffuseColor = vColor;\n    if (useGradient == 1.) diffuseColor = vec4(mix(gradient[0], gradient[1], vCounters), 1.0);\n    if (useMap == 1.) diffuseColor *= texture2D(map, vUV * repeat);\n    if (useAlphaMap == 1.) diffuseColor.a *= texture2D(alphaMap, vUV * repeat).a;\n    if (diffuseColor.a < alphaTest) discard;\n    if (useDash == 1.) diffuseColor.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\n    diffuseColor.a *= step(vCounters, visibility);\n    #include <clipping_planes_fragment>\n    gl_FragColor = diffuseColor;     \n    #include <fog_fragment>\n    #include <tonemapping_fragment>\n    #include <${colorspace_fragment}>\n  }\n`;\nclass MeshLineMaterial extends THREE__namespace.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: {\n        ...THREE__namespace.UniformsLib.fog,\n        lineWidth: { value: 1 },\n        map: { value: null },\n        useMap: { value: 0 },\n        alphaMap: { value: null },\n        useAlphaMap: { value: 0 },\n        color: { value: new THREE__namespace.Color(16777215) },\n        gradient: { value: [new THREE__namespace.Color(16711680), new THREE__namespace.Color(65280)] },\n        opacity: { value: 1 },\n        resolution: { value: new THREE__namespace.Vector2(1, 1) },\n        sizeAttenuation: { value: 1 },\n        dashArray: { value: 0 },\n        dashOffset: { value: 0 },\n        dashRatio: { value: 0.5 },\n        useDash: { value: 0 },\n        useGradient: { value: 0 },\n        visibility: { value: 1 },\n        alphaTest: { value: 0 },\n        repeat: { value: new THREE__namespace.Vector2(1, 1) }\n      },\n      vertexShader,\n      fragmentShader\n    });\n    __publicField(this, \"lineWidth\");\n    __publicField(this, \"map\");\n    __publicField(this, \"useMap\");\n    __publicField(this, \"alphaMap\");\n    __publicField(this, \"useAlphaMap\");\n    __publicField(this, \"color\");\n    __publicField(this, \"gradient\");\n    __publicField(this, \"opacity\", 1);\n    __publicField(this, \"resolution\");\n    __publicField(this, \"sizeAttenuation\");\n    __publicField(this, \"dashArray\");\n    __publicField(this, \"dashOffset\");\n    __publicField(this, \"dashRatio\");\n    __publicField(this, \"useDash\");\n    __publicField(this, \"useGradient\");\n    __publicField(this, \"visibility\");\n    __publicField(this, \"alphaTest\", 0);\n    __publicField(this, \"repeat\");\n    this.type = \"MeshLineMaterial\";\n    Object.defineProperties(this, {\n      lineWidth: {\n        enumerable: true,\n        get() {\n          return this.uniforms.lineWidth.value;\n        },\n        set(value) {\n          this.uniforms.lineWidth.value = value;\n        }\n      },\n      map: {\n        enumerable: true,\n        get() {\n          return this.uniforms.map.value;\n        },\n        set(value) {\n          this.uniforms.map.value = value;\n        }\n      },\n      useMap: {\n        enumerable: true,\n        get() {\n          return this.uniforms.useMap.value;\n        },\n        set(value) {\n          this.uniforms.useMap.value = value;\n        }\n      },\n      alphaMap: {\n        enumerable: true,\n        get() {\n          return this.uniforms.alphaMap.value;\n        },\n        set(value) {\n          this.uniforms.alphaMap.value = value;\n        }\n      },\n      useAlphaMap: {\n        enumerable: true,\n        get() {\n          return this.uniforms.useAlphaMap.value;\n        },\n        set(value) {\n          this.uniforms.useAlphaMap.value = value;\n        }\n      },\n      color: {\n        enumerable: true,\n        get() {\n          return this.uniforms.color.value;\n        },\n        set(value) {\n          this.uniforms.color.value = value;\n        }\n      },\n      gradient: {\n        enumerable: true,\n        get() {\n          return this.uniforms.gradient.value;\n        },\n        set(value) {\n          this.uniforms.gradient.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get() {\n          return this.uniforms.opacity.value;\n        },\n        set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get() {\n          return this.uniforms.resolution.value;\n        },\n        set(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      sizeAttenuation: {\n        enumerable: true,\n        get() {\n          return this.uniforms.sizeAttenuation.value;\n        },\n        set(value) {\n          this.uniforms.sizeAttenuation.value = value;\n        }\n      },\n      dashArray: {\n        enumerable: true,\n        get() {\n          return this.uniforms.dashArray.value;\n        },\n        set(value) {\n          this.uniforms.dashArray.value = value;\n          this.useDash = value !== 0 ? 1 : 0;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get() {\n          return this.uniforms.dashOffset.value;\n        },\n        set(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      dashRatio: {\n        enumerable: true,\n        get() {\n          return this.uniforms.dashRatio.value;\n        },\n        set(value) {\n          this.uniforms.dashRatio.value = value;\n        }\n      },\n      useDash: {\n        enumerable: true,\n        get() {\n          return this.uniforms.useDash.value;\n        },\n        set(value) {\n          this.uniforms.useDash.value = value;\n        }\n      },\n      useGradient: {\n        enumerable: true,\n        get() {\n          return this.uniforms.useGradient.value;\n        },\n        set(value) {\n          this.uniforms.useGradient.value = value;\n        }\n      },\n      visibility: {\n        enumerable: true,\n        get() {\n          return this.uniforms.visibility.value;\n        },\n        set(value) {\n          this.uniforms.visibility.value = value;\n        }\n      },\n      alphaTest: {\n        enumerable: true,\n        get() {\n          return this.uniforms.alphaTest.value;\n        },\n        set(value) {\n          this.uniforms.alphaTest.value = value;\n        }\n      },\n      repeat: {\n        enumerable: true,\n        get() {\n          return this.uniforms.repeat.value;\n        },\n        set(value) {\n          this.uniforms.repeat.value.copy(value);\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.lineWidth = source.lineWidth;\n    this.map = source.map;\n    this.useMap = source.useMap;\n    this.alphaMap = source.alphaMap;\n    this.useAlphaMap = source.useAlphaMap;\n    this.color.copy(source.color);\n    this.gradient = source.gradient;\n    this.opacity = source.opacity;\n    this.resolution.copy(source.resolution);\n    this.sizeAttenuation = source.sizeAttenuation;\n    this.dashArray = source.dashArray;\n    this.dashOffset = source.dashOffset;\n    this.dashRatio = source.dashRatio;\n    this.useDash = source.useDash;\n    this.useGradient = source.useGradient;\n    this.visibility = source.visibility;\n    this.alphaTest = source.alphaTest;\n    this.repeat.copy(source.repeat);\n    return this;\n  }\n}\nfunction raycast(raycaster, intersects) {\n  const inverseMatrix = new THREE__namespace.Matrix4();\n  const ray = new THREE__namespace.Ray();\n  const sphere = new THREE__namespace.Sphere();\n  const interRay = new THREE__namespace.Vector3();\n  const geometry = this.geometry;\n  sphere.copy(geometry.boundingSphere);\n  sphere.applyMatrix4(this.matrixWorld);\n  if (!raycaster.ray.intersectSphere(sphere, interRay))\n    return;\n  inverseMatrix.copy(this.matrixWorld).invert();\n  ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n  const vStart = new THREE__namespace.Vector3();\n  const vEnd = new THREE__namespace.Vector3();\n  const interSegment = new THREE__namespace.Vector3();\n  const step = this instanceof THREE__namespace.LineSegments ? 2 : 1;\n  const index = geometry.index;\n  const attributes = geometry.attributes;\n  if (index !== null) {\n    const indices = index.array;\n    const positions = attributes.position.array;\n    const widths = attributes.width.array;\n    for (let i = 0, l = indices.length - 1; i < l; i += step) {\n      const a = indices[i];\n      const b = indices[i + 1];\n      vStart.fromArray(positions, a * 3);\n      vEnd.fromArray(positions, b * 3);\n      const width = widths[Math.floor(i / 3)] != void 0 ? widths[Math.floor(i / 3)] : 1;\n      const precision = raycaster.params.Line.threshold + this.material.lineWidth * width / 2;\n      const precisionSq = precision * precision;\n      const distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n      if (distSq > precisionSq)\n        continue;\n      interRay.applyMatrix4(this.matrixWorld);\n      const distance = raycaster.ray.origin.distanceTo(interRay);\n      if (distance < raycaster.near || distance > raycaster.far)\n        continue;\n      intersects.push({\n        distance,\n        point: interSegment.clone().applyMatrix4(this.matrixWorld),\n        index: i,\n        face: null,\n        faceIndex: void 0,\n        object: this\n      });\n      i = l;\n    }\n  }\n}\nexports.MeshLineGeometry = MeshLineGeometry;\nexports.MeshLineMaterial = MeshLineMaterial;\nexports.raycast = raycast;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVzaGxpbmUvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYyxhQUFhLDBCQUEwQixtQkFBbUI7QUFDM0csY0FBYyxtQkFBTyxDQUFDLHlEQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0IsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0IsZUFBZSxhQUFhO0FBQzVCLGtCQUFrQixVQUFVO0FBQzVCLG9CQUFvQixhQUFhO0FBQ2pDLHVCQUF1QixVQUFVO0FBQ2pDLGlCQUFpQiw2Q0FBNkM7QUFDOUQsb0JBQW9CLGtGQUFrRjtBQUN0RyxtQkFBbUIsVUFBVTtBQUM3QixzQkFBc0IsMkNBQTJDO0FBQ2pFLDJCQUEyQixVQUFVO0FBQ3JDLHFCQUFxQixVQUFVO0FBQy9CLHNCQUFzQixVQUFVO0FBQ2hDLHFCQUFxQixZQUFZO0FBQ2pDLG1CQUFtQixVQUFVO0FBQzdCLHVCQUF1QixVQUFVO0FBQ2pDLHNCQUFzQixVQUFVO0FBQ2hDLHFCQUFxQixVQUFVO0FBQy9CLGtCQUFrQjtBQUNsQixPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcmVhbWctbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21lc2hsaW5lL2Rpc3QvaW5kZXguY2pzPzE1NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhleHBvcnRzLCB7IF9fZXNNb2R1bGU6IHsgdmFsdWU6IHRydWUgfSwgW1N5bWJvbC50b1N0cmluZ1RhZ106IHsgdmFsdWU6IFwiTW9kdWxlXCIgfSB9KTtcbmNvbnN0IFRIUkVFID0gcmVxdWlyZShcInRocmVlXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpXG4gICAgcmV0dXJuIGU7XG4gIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKG51bGwsIHsgW1N5bWJvbC50b1N0cmluZ1RhZ106IHsgdmFsdWU6IFwiTW9kdWxlXCIgfSB9KTtcbiAgaWYgKGUpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gZSkge1xuICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIGNvbnN0IGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiAoKSA9PiBlW2tdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cbmNvbnN0IFRIUkVFX19uYW1lc3BhY2UgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BOYW1lc3BhY2UoVEhSRUUpO1xuZnVuY3Rpb24gbWVtY3B5KHNyYywgc3JjT2Zmc2V0LCBkc3QsIGRzdE9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpO1xuICBzcmMgPSBzcmMuc3ViYXJyYXkgfHwgc3JjLnNsaWNlID8gc3JjIDogc3JjLmJ1ZmZlcjtcbiAgZHN0ID0gZHN0LnN1YmFycmF5IHx8IGRzdC5zbGljZSA/IGRzdCA6IGRzdC5idWZmZXI7XG4gIHNyYyA9IHNyY09mZnNldCA/IHNyYy5zdWJhcnJheSA/IHNyYy5zdWJhcnJheShzcmNPZmZzZXQsIGxlbmd0aCAmJiBzcmNPZmZzZXQgKyBsZW5ndGgpIDogc3JjLnNsaWNlKHNyY09mZnNldCwgbGVuZ3RoICYmIHNyY09mZnNldCArIGxlbmd0aCkgOiBzcmM7XG4gIGlmIChkc3Quc2V0KSB7XG4gICAgZHN0LnNldChzcmMsIGRzdE9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkrKylcbiAgICAgIGRzdFtpICsgZHN0T2Zmc2V0XSA9IHNyY1tpXTtcbiAgfVxuICByZXR1cm4gZHN0O1xufVxuZnVuY3Rpb24gY29udmVydFBvaW50cyhwb2ludHMpIHtcbiAgaWYgKHBvaW50cyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcbiAgICByZXR1cm4gcG9pbnRzO1xuICBpZiAocG9pbnRzIGluc3RhbmNlb2YgVEhSRUVfX25hbWVzcGFjZS5CdWZmZXJHZW9tZXRyeSlcbiAgICByZXR1cm4gcG9pbnRzLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpLmFycmF5O1xuICByZXR1cm4gcG9pbnRzLm1hcCgocCkgPT4ge1xuICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHApO1xuICAgIHJldHVybiBwIGluc3RhbmNlb2YgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzID8gW3AueCwgcC55LCBwLnpdIDogcCBpbnN0YW5jZW9mIFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMiA/IFtwLngsIHAueSwgMF0gOiBpc0FycmF5ICYmIHAubGVuZ3RoID09PSAzID8gW3BbMF0sIHBbMV0sIHBbMl1dIDogaXNBcnJheSAmJiBwLmxlbmd0aCA9PT0gMiA/IFtwWzBdLCBwWzFdLCAwXSA6IHA7XG4gIH0pLmZsYXQoKTtcbn1cbmNsYXNzIE1lc2hMaW5lR2VvbWV0cnkgZXh0ZW5kcyBUSFJFRV9fbmFtZXNwYWNlLkJ1ZmZlckdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidHlwZVwiLCBcIk1lc2hMaW5lXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc01lc2hMaW5lXCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwb3NpdGlvbnNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcmV2aW91c1wiLCBbXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5leHRcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaWRlXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwid2lkdGhcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmRpY2VzX2FycmF5XCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXZzXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY291bnRlcnNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ3aWR0aENhbGxiYWNrXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYXR0cmlidXRlc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3BvaW50c1wiLCBbXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBvaW50c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWF0cml4V29ybGRcIiwgbmV3IFRIUkVFX19uYW1lc3BhY2UuTWF0cml4NCgpKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBwb2ludHM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuc2V0UG9pbnRzKHZhbHVlLCB0aGlzLndpZHRoQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0TWF0cml4V29ybGQobWF0cml4V29ybGQpIHtcbiAgICB0aGlzLm1hdHJpeFdvcmxkID0gbWF0cml4V29ybGQ7XG4gIH1cbiAgc2V0UG9pbnRzKHBvaW50cywgd2NiKSB7XG4gICAgcG9pbnRzID0gY29udmVydFBvaW50cyhwb2ludHMpO1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICB0aGlzLndpZHRoQ2FsbGJhY2sgPSB3Y2IgIT0gbnVsbCA/IHdjYiA6IG51bGw7XG4gICAgdGhpcy5wb3NpdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvdW50ZXJzID0gW107XG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgcG9pbnRzWzBdIGluc3RhbmNlb2YgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBwID0gcG9pbnRzW2pdO1xuICAgICAgICBjb25zdCBjID0gaiAvIChwb2ludHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLnB1c2gocC54LCBwLnksIHAueik7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLnB1c2gocC54LCBwLnksIHAueik7XG4gICAgICAgIHRoaXMuY291bnRlcnMucHVzaChjKTtcbiAgICAgICAgdGhpcy5jb3VudGVycy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGogKz0gMykge1xuICAgICAgICBjb25zdCBjID0gaiAvIChwb2ludHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLnB1c2gocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBwb2ludHNbaiArIDJdKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMucHVzaChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIHBvaW50c1tqICsgMl0pO1xuICAgICAgICB0aGlzLmNvdW50ZXJzLnB1c2goYyk7XG4gICAgICAgIHRoaXMuY291bnRlcnMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9jZXNzKCk7XG4gIH1cbiAgY29tcGFyZVYzKGEsIGIpIHtcbiAgICBjb25zdCBhYSA9IGEgKiA2O1xuICAgIGNvbnN0IGFiID0gYiAqIDY7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25zW2FhXSA9PT0gdGhpcy5wb3NpdGlvbnNbYWJdICYmIHRoaXMucG9zaXRpb25zW2FhICsgMV0gPT09IHRoaXMucG9zaXRpb25zW2FiICsgMV0gJiYgdGhpcy5wb3NpdGlvbnNbYWEgKyAyXSA9PT0gdGhpcy5wb3NpdGlvbnNbYWIgKyAyXTtcbiAgfVxuICBjb3B5VjMoYSkge1xuICAgIGNvbnN0IGFhID0gYSAqIDY7XG4gICAgcmV0dXJuIFt0aGlzLnBvc2l0aW9uc1thYV0sIHRoaXMucG9zaXRpb25zW2FhICsgMV0sIHRoaXMucG9zaXRpb25zW2FhICsgMl1dO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgY29uc3QgbCA9IHRoaXMucG9zaXRpb25zLmxlbmd0aCAvIDY7XG4gICAgdGhpcy5wcmV2aW91cyA9IFtdO1xuICAgIHRoaXMubmV4dCA9IFtdO1xuICAgIHRoaXMuc2lkZSA9IFtdO1xuICAgIHRoaXMud2lkdGggPSBbXTtcbiAgICB0aGlzLmluZGljZXNfYXJyYXkgPSBbXTtcbiAgICB0aGlzLnV2cyA9IFtdO1xuICAgIGxldCB3O1xuICAgIGxldCB2O1xuICAgIGlmICh0aGlzLmNvbXBhcmVWMygwLCBsIC0gMSkpIHtcbiAgICAgIHYgPSB0aGlzLmNvcHlWMyhsIC0gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSBbXG4gICAgICAgIHRoaXMucG9zaXRpb25zWzBdIC0gKHRoaXMucG9zaXRpb25zWzZdIC0gdGhpcy5wb3NpdGlvbnNbMF0pLFxuICAgICAgICB0aGlzLnBvc2l0aW9uc1sxXSAtICh0aGlzLnBvc2l0aW9uc1s2ICsgMV0gLSB0aGlzLnBvc2l0aW9uc1sxXSksXG4gICAgICAgIHRoaXMucG9zaXRpb25zWzJdIC0gKHRoaXMucG9zaXRpb25zWzYgKyAyXSAtIHRoaXMucG9zaXRpb25zWzJdKVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5wcmV2aW91cy5wdXNoKHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgIHRoaXMucHJldmlvdXMucHVzaCh2WzBdLCB2WzFdLCB2WzJdKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgdGhpcy5zaWRlLnB1c2goMSk7XG4gICAgICB0aGlzLnNpZGUucHVzaCgtMSk7XG4gICAgICBpZiAodGhpcy53aWR0aENhbGxiYWNrKVxuICAgICAgICB3ID0gdGhpcy53aWR0aENhbGxiYWNrKGogLyAobCAtIDEpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdyA9IDE7XG4gICAgICB0aGlzLndpZHRoLnB1c2godyk7XG4gICAgICB0aGlzLndpZHRoLnB1c2godyk7XG4gICAgICB0aGlzLnV2cy5wdXNoKGogLyAobCAtIDEpLCAwKTtcbiAgICAgIHRoaXMudXZzLnB1c2goaiAvIChsIC0gMSksIDEpO1xuICAgICAgaWYgKGogPCBsIC0gMSkge1xuICAgICAgICB2ID0gdGhpcy5jb3B5VjMoaik7XG4gICAgICAgIHRoaXMucHJldmlvdXMucHVzaCh2WzBdLCB2WzFdLCB2WzJdKTtcbiAgICAgICAgdGhpcy5wcmV2aW91cy5wdXNoKHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgICAgICBjb25zdCBuID0gaiAqIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc19hcnJheS5wdXNoKG4sIG4gKyAxLCBuICsgMik7XG4gICAgICAgIHRoaXMuaW5kaWNlc19hcnJheS5wdXNoKG4gKyAyLCBuICsgMSwgbiArIDMpO1xuICAgICAgfVxuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHYgPSB0aGlzLmNvcHlWMyhqKTtcbiAgICAgICAgdGhpcy5uZXh0LnB1c2godlswXSwgdlsxXSwgdlsyXSk7XG4gICAgICAgIHRoaXMubmV4dC5wdXNoKHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jb21wYXJlVjMobCAtIDEsIDApKSB7XG4gICAgICB2ID0gdGhpcy5jb3B5VjMoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSBbXG4gICAgICAgIHRoaXMucG9zaXRpb25zW2wgLSAxXSArICh0aGlzLnBvc2l0aW9uc1tsIC0gMV0gLSB0aGlzLnBvc2l0aW9uc1tsIC0gMSAtIDZdKSxcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNbbCAtIDJdICsgKHRoaXMucG9zaXRpb25zW2wgLSAyXSAtIHRoaXMucG9zaXRpb25zW2wgLSAyIC0gNl0pLFxuICAgICAgICB0aGlzLnBvc2l0aW9uc1tsIC0gM10gKyAodGhpcy5wb3NpdGlvbnNbbCAtIDNdIC0gdGhpcy5wb3NpdGlvbnNbbCAtIDMgLSA2XSlcbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMubmV4dC5wdXNoKHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgIHRoaXMubmV4dC5wdXNoKHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgIGlmICghdGhpcy5fYXR0cmlidXRlcyB8fCB0aGlzLl9hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICE9PSB0aGlzLmNvdW50ZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fYXR0cmlidXRlcyA9IHtcbiAgICAgICAgcG9zaXRpb246IG5ldyBUSFJFRV9fbmFtZXNwYWNlLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KHRoaXMucG9zaXRpb25zKSwgMyksXG4gICAgICAgIHByZXZpb3VzOiBuZXcgVEhSRUVfX25hbWVzcGFjZS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSh0aGlzLnByZXZpb3VzKSwgMyksXG4gICAgICAgIG5leHQ6IG5ldyBUSFJFRV9fbmFtZXNwYWNlLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KHRoaXMubmV4dCksIDMpLFxuICAgICAgICBzaWRlOiBuZXcgVEhSRUVfX25hbWVzcGFjZS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSh0aGlzLnNpZGUpLCAxKSxcbiAgICAgICAgd2lkdGg6IG5ldyBUSFJFRV9fbmFtZXNwYWNlLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KHRoaXMud2lkdGgpLCAxKSxcbiAgICAgICAgdXY6IG5ldyBUSFJFRV9fbmFtZXNwYWNlLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KHRoaXMudXZzKSwgMiksXG4gICAgICAgIGluZGV4OiBuZXcgVEhSRUVfX25hbWVzcGFjZS5CdWZmZXJBdHRyaWJ1dGUobmV3IFVpbnQxNkFycmF5KHRoaXMuaW5kaWNlc19hcnJheSksIDEpLFxuICAgICAgICBjb3VudGVyczogbmV3IFRIUkVFX19uYW1lc3BhY2UuQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5jb3VudGVycyksIDEpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvcHlBcnJheShuZXcgRmxvYXQzMkFycmF5KHRoaXMucG9zaXRpb25zKSk7XG4gICAgICB0aGlzLl9hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2F0dHJpYnV0ZXMucHJldmlvdXMuY29weUFycmF5KG5ldyBGbG9hdDMyQXJyYXkodGhpcy5wcmV2aW91cykpO1xuICAgICAgdGhpcy5fYXR0cmlidXRlcy5wcmV2aW91cy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLl9hdHRyaWJ1dGVzLm5leHQuY29weUFycmF5KG5ldyBGbG9hdDMyQXJyYXkodGhpcy5uZXh0KSk7XG4gICAgICB0aGlzLl9hdHRyaWJ1dGVzLm5leHQubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5fYXR0cmlidXRlcy5zaWRlLmNvcHlBcnJheShuZXcgRmxvYXQzMkFycmF5KHRoaXMuc2lkZSkpO1xuICAgICAgdGhpcy5fYXR0cmlidXRlcy5zaWRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2F0dHJpYnV0ZXMud2lkdGguY29weUFycmF5KG5ldyBGbG9hdDMyQXJyYXkodGhpcy53aWR0aCkpO1xuICAgICAgdGhpcy5fYXR0cmlidXRlcy53aWR0aC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLl9hdHRyaWJ1dGVzLnV2LmNvcHlBcnJheShuZXcgRmxvYXQzMkFycmF5KHRoaXMudXZzKSk7XG4gICAgICB0aGlzLl9hdHRyaWJ1dGVzLnV2Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2F0dHJpYnV0ZXMuaW5kZXguY29weUFycmF5KG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXNfYXJyYXkpKTtcbiAgICAgIHRoaXMuX2F0dHJpYnV0ZXMuaW5kZXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIHRoaXMuX2F0dHJpYnV0ZXMucG9zaXRpb24pO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwicHJldmlvdXNcIiwgdGhpcy5fYXR0cmlidXRlcy5wcmV2aW91cyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJuZXh0XCIsIHRoaXMuX2F0dHJpYnV0ZXMubmV4dCk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJzaWRlXCIsIHRoaXMuX2F0dHJpYnV0ZXMuc2lkZSk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0aGlzLl9hdHRyaWJ1dGVzLndpZHRoKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcInV2XCIsIHRoaXMuX2F0dHJpYnV0ZXMudXYpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiY291bnRlcnNcIiwgdGhpcy5fYXR0cmlidXRlcy5jb3VudGVycyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCB0aGlzLl9hdHRyaWJ1dGVzLnBvc2l0aW9uKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcInByZXZpb3VzXCIsIHRoaXMuX2F0dHJpYnV0ZXMucHJldmlvdXMpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwibmV4dFwiLCB0aGlzLl9hdHRyaWJ1dGVzLm5leHQpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwic2lkZVwiLCB0aGlzLl9hdHRyaWJ1dGVzLnNpZGUpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdGhpcy5fYXR0cmlidXRlcy53aWR0aCk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCB0aGlzLl9hdHRyaWJ1dGVzLnV2KTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImNvdW50ZXJzXCIsIHRoaXMuX2F0dHJpYnV0ZXMuY291bnRlcnMpO1xuICAgIHRoaXMuc2V0SW5kZXgodGhpcy5fYXR0cmlidXRlcy5pbmRleCk7XG4gICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICB9XG4gIGFkdmFuY2UoeyB4LCB5LCB6IH0pIHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLl9hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5fYXR0cmlidXRlcy5wcmV2aW91cy5hcnJheTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5fYXR0cmlidXRlcy5uZXh0LmFycmF5O1xuICAgIGNvbnN0IGwgPSBwb3NpdGlvbnMubGVuZ3RoO1xuICAgIG1lbWNweShwb3NpdGlvbnMsIDAsIHByZXZpb3VzLCAwLCBsKTtcbiAgICBtZW1jcHkocG9zaXRpb25zLCA2LCBwb3NpdGlvbnMsIDAsIGwgLSA2KTtcbiAgICBwb3NpdGlvbnNbbCAtIDZdID0geDtcbiAgICBwb3NpdGlvbnNbbCAtIDVdID0geTtcbiAgICBwb3NpdGlvbnNbbCAtIDRdID0gejtcbiAgICBwb3NpdGlvbnNbbCAtIDNdID0geDtcbiAgICBwb3NpdGlvbnNbbCAtIDJdID0geTtcbiAgICBwb3NpdGlvbnNbbCAtIDFdID0gejtcbiAgICBtZW1jcHkocG9zaXRpb25zLCA2LCBuZXh0LCAwLCBsIC0gNik7XG4gICAgbmV4dFtsIC0gNl0gPSB4O1xuICAgIG5leHRbbCAtIDVdID0geTtcbiAgICBuZXh0W2wgLSA0XSA9IHo7XG4gICAgbmV4dFtsIC0gM10gPSB4O1xuICAgIG5leHRbbCAtIDJdID0geTtcbiAgICBuZXh0W2wgLSAxXSA9IHo7XG4gICAgdGhpcy5fYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5fYXR0cmlidXRlcy5wcmV2aW91cy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5fYXR0cmlidXRlcy5uZXh0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxufVxuY29uc3QgdmVydGV4U2hhZGVyID0gYFxuICAjaW5jbHVkZSA8Y29tbW9uPlxuICAjaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XG4gICNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XG4gICNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XG5cbiAgYXR0cmlidXRlIHZlYzMgcHJldmlvdXM7XG4gIGF0dHJpYnV0ZSB2ZWMzIG5leHQ7XG4gIGF0dHJpYnV0ZSBmbG9hdCBzaWRlO1xuICBhdHRyaWJ1dGUgZmxvYXQgd2lkdGg7XG4gIGF0dHJpYnV0ZSBmbG9hdCBjb3VudGVycztcbiAgXG4gIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICB1bmlmb3JtIGZsb2F0IGxpbmVXaWR0aDtcbiAgdW5pZm9ybSB2ZWMzIGNvbG9yO1xuICB1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG4gIHVuaWZvcm0gZmxvYXQgc2l6ZUF0dGVudWF0aW9uO1xuICBcbiAgdmFyeWluZyB2ZWMyIHZVVjtcbiAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgdmFyeWluZyBmbG9hdCB2Q291bnRlcnM7XG4gIFxuICB2ZWMyIGZpeCh2ZWM0IGksIGZsb2F0IGFzcGVjdCkge1xuICAgIHZlYzIgcmVzID0gaS54eSAvIGkudztcbiAgICByZXMueCAqPSBhc3BlY3Q7XG4gIFx0dkNvdW50ZXJzID0gY291bnRlcnM7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBcbiAgdm9pZCBtYWluKCkge1xuICAgIGZsb2F0IGFzcGVjdCA9IHJlc29sdXRpb24ueCAvIHJlc29sdXRpb24ueTtcbiAgICB2Q29sb3IgPSB2ZWM0KGNvbG9yLCBvcGFjaXR5KTtcbiAgICB2VVYgPSB1djtcbiAgXG4gICAgbWF0NCBtID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeDtcbiAgICB2ZWM0IGZpbmFsUG9zaXRpb24gPSBtICogdmVjNChwb3NpdGlvbiwgMS4wKSAqIGFzcGVjdDtcbiAgICB2ZWM0IHByZXZQb3MgPSBtICogdmVjNChwcmV2aW91cywgMS4wKTtcbiAgICB2ZWM0IG5leHRQb3MgPSBtICogdmVjNChuZXh0LCAxLjApO1xuICBcbiAgICB2ZWMyIGN1cnJlbnRQID0gZml4KGZpbmFsUG9zaXRpb24sIGFzcGVjdCk7XG4gICAgdmVjMiBwcmV2UCA9IGZpeChwcmV2UG9zLCBhc3BlY3QpO1xuICAgIHZlYzIgbmV4dFAgPSBmaXgobmV4dFBvcywgYXNwZWN0KTtcbiAgXG4gICAgZmxvYXQgdyA9IGxpbmVXaWR0aCAqIHdpZHRoO1xuICBcbiAgICB2ZWMyIGRpcjEgPSBub3JtYWxpemUoY3VycmVudFAgLSBwcmV2UCk7XG4gICAgdmVjMiBkaXIyID0gbm9ybWFsaXplKG5leHRQIC0gY3VycmVudFApO1xuICAgIHZlYzIgZGlyID0gbm9ybWFsaXplKGRpcjEgKyBkaXIyKTtcblxuICAgIHZlYzIgcGVycCA9IHZlYzIoLWRpcjEueSwgZGlyMS54KTtcbiAgICB2ZWMyIG1pdGVyID0gdmVjMigtZGlyLnksIGRpci54KTtcbiAgICAvL3cgPSBjbGFtcCh3IC8gZG90KG1pdGVyLCBwZXJwKSwgMC4sIDQuICogbGluZVdpZHRoICogd2lkdGgpO1xuICBcbiAgICAvL3ZlYzIgbm9ybWFsID0gKGNyb3NzKHZlYzMoZGlyLCAwLiksIHZlYzMoMC4sIDAuLCAxLikpKS54eTtcbiAgICB2ZWM0IG5vcm1hbCA9IHZlYzQoLWRpci55LCBkaXIueCwgMC4sIDEuKTtcbiAgICBub3JtYWwueHkgKj0gLjUgKiB3O1xuICAgIC8vbm9ybWFsICo9IHByb2plY3Rpb25NYXRyaXg7XG4gICAgaWYgKHNpemVBdHRlbnVhdGlvbiA9PSAwLikge1xuICAgICAgbm9ybWFsLnh5ICo9IGZpbmFsUG9zaXRpb24udztcbiAgICAgIG5vcm1hbC54eSAvPSAodmVjNChyZXNvbHV0aW9uLCAwLiwgMS4pICogcHJvamVjdGlvbk1hdHJpeCkueHkgKiBhc3BlY3Q7XG4gICAgfVxuICBcbiAgICBmaW5hbFBvc2l0aW9uLnh5ICs9IG5vcm1hbC54eSAqIHNpZGU7XG4gICAgZ2xfUG9zaXRpb24gPSBmaW5hbFBvc2l0aW9uO1xuICAgICNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XG4gICAgI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XG4gICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICAjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cbiAgICAjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cbiAgfVxuYDtcbmNvbnN0IHZlcnNpb24gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHBhcnNlSW50KFRIUkVFX19uYW1lc3BhY2UuUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSkpKCk7XG5jb25zdCBjb2xvcnNwYWNlX2ZyYWdtZW50ID0gdmVyc2lvbiA+PSAxNTQgPyBcImNvbG9yc3BhY2VfZnJhZ21lbnRcIiA6IFwiZW5jb2RpbmdzX2ZyYWdtZW50XCI7XG5jb25zdCBmcmFnbWVudFNoYWRlciA9IGBcbiAgI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxuICAjaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cbiAgI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxuICBcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xuICB1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcbiAgdW5pZm9ybSBmbG9hdCB1c2VHcmFkaWVudDtcbiAgdW5pZm9ybSBmbG9hdCB1c2VNYXA7XG4gIHVuaWZvcm0gZmxvYXQgdXNlQWxwaGFNYXA7XG4gIHVuaWZvcm0gZmxvYXQgdXNlRGFzaDtcbiAgdW5pZm9ybSBmbG9hdCBkYXNoQXJyYXk7XG4gIHVuaWZvcm0gZmxvYXQgZGFzaE9mZnNldDtcbiAgdW5pZm9ybSBmbG9hdCBkYXNoUmF0aW87XG4gIHVuaWZvcm0gZmxvYXQgdmlzaWJpbGl0eTtcbiAgdW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7XG4gIHVuaWZvcm0gdmVjMiByZXBlYXQ7XG4gIHVuaWZvcm0gdmVjMyBncmFkaWVudFsyXTtcbiAgXG4gIHZhcnlpbmcgdmVjMiB2VVY7XG4gIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gIHZhcnlpbmcgZmxvYXQgdkNvdW50ZXJzO1xuICBcbiAgdm9pZCBtYWluKCkge1xuICAgICNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cbiAgICB2ZWM0IGRpZmZ1c2VDb2xvciA9IHZDb2xvcjtcbiAgICBpZiAodXNlR3JhZGllbnQgPT0gMS4pIGRpZmZ1c2VDb2xvciA9IHZlYzQobWl4KGdyYWRpZW50WzBdLCBncmFkaWVudFsxXSwgdkNvdW50ZXJzKSwgMS4wKTtcbiAgICBpZiAodXNlTWFwID09IDEuKSBkaWZmdXNlQ29sb3IgKj0gdGV4dHVyZTJEKG1hcCwgdlVWICogcmVwZWF0KTtcbiAgICBpZiAodXNlQWxwaGFNYXAgPT0gMS4pIGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRChhbHBoYU1hcCwgdlVWICogcmVwZWF0KS5hO1xuICAgIGlmIChkaWZmdXNlQ29sb3IuYSA8IGFscGhhVGVzdCkgZGlzY2FyZDtcbiAgICBpZiAodXNlRGFzaCA9PSAxLikgZGlmZnVzZUNvbG9yLmEgKj0gY2VpbChtb2QodkNvdW50ZXJzICsgZGFzaE9mZnNldCwgZGFzaEFycmF5KSAtIChkYXNoQXJyYXkgKiBkYXNoUmF0aW8pKTtcbiAgICBkaWZmdXNlQ29sb3IuYSAqPSBzdGVwKHZDb3VudGVycywgdmlzaWJpbGl0eSk7XG4gICAgI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cbiAgICBnbF9GcmFnQ29sb3IgPSBkaWZmdXNlQ29sb3I7ICAgICBcbiAgICAjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxuICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAjaW5jbHVkZSA8JHtjb2xvcnNwYWNlX2ZyYWdtZW50fT5cbiAgfVxuYDtcbmNsYXNzIE1lc2hMaW5lTWF0ZXJpYWwgZXh0ZW5kcyBUSFJFRV9fbmFtZXNwYWNlLlNoYWRlck1hdGVyaWFsIHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHtcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIC4uLlRIUkVFX19uYW1lc3BhY2UuVW5pZm9ybXNMaWIuZm9nLFxuICAgICAgICBsaW5lV2lkdGg6IHsgdmFsdWU6IDEgfSxcbiAgICAgICAgbWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgICAgIHVzZU1hcDogeyB2YWx1ZTogMCB9LFxuICAgICAgICBhbHBoYU1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgICAgICB1c2VBbHBoYU1hcDogeyB2YWx1ZTogMCB9LFxuICAgICAgICBjb2xvcjogeyB2YWx1ZTogbmV3IFRIUkVFX19uYW1lc3BhY2UuQ29sb3IoMTY3NzcyMTUpIH0sXG4gICAgICAgIGdyYWRpZW50OiB7IHZhbHVlOiBbbmV3IFRIUkVFX19uYW1lc3BhY2UuQ29sb3IoMTY3MTE2ODApLCBuZXcgVEhSRUVfX25hbWVzcGFjZS5Db2xvcig2NTI4MCldIH0sXG4gICAgICAgIG9wYWNpdHk6IHsgdmFsdWU6IDEgfSxcbiAgICAgICAgcmVzb2x1dGlvbjogeyB2YWx1ZTogbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMigxLCAxKSB9LFxuICAgICAgICBzaXplQXR0ZW51YXRpb246IHsgdmFsdWU6IDEgfSxcbiAgICAgICAgZGFzaEFycmF5OiB7IHZhbHVlOiAwIH0sXG4gICAgICAgIGRhc2hPZmZzZXQ6IHsgdmFsdWU6IDAgfSxcbiAgICAgICAgZGFzaFJhdGlvOiB7IHZhbHVlOiAwLjUgfSxcbiAgICAgICAgdXNlRGFzaDogeyB2YWx1ZTogMCB9LFxuICAgICAgICB1c2VHcmFkaWVudDogeyB2YWx1ZTogMCB9LFxuICAgICAgICB2aXNpYmlsaXR5OiB7IHZhbHVlOiAxIH0sXG4gICAgICAgIGFscGhhVGVzdDogeyB2YWx1ZTogMCB9LFxuICAgICAgICByZXBlYXQ6IHsgdmFsdWU6IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjIoMSwgMSkgfVxuICAgICAgfSxcbiAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyXG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxpbmVXaWR0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFwXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1c2VNYXBcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFscGhhTWFwXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1c2VBbHBoYU1hcFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29sb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdyYWRpZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvcGFjaXR5XCIsIDEpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXNvbHV0aW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaXplQXR0ZW51YXRpb25cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRhc2hBcnJheVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGFzaE9mZnNldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGFzaFJhdGlvXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1c2VEYXNoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1c2VHcmFkaWVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmlzaWJpbGl0eVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWxwaGFUZXN0XCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXBlYXRcIik7XG4gICAgdGhpcy50eXBlID0gXCJNZXNoTGluZU1hdGVyaWFsXCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgbGluZVdpZHRoOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5saW5lV2lkdGgudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMubGluZVdpZHRoLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtYXA6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hcC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXAudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZU1hcDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudXNlTWFwLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVzZU1hcC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWxwaGFNYXA6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmFscGhhTWFwLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VBbHBoYU1hcDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudXNlQWxwaGFNYXAudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMudXNlQWxwaGFNYXAudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jb2xvci52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5jb2xvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdyYWRpZW50LnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLmdyYWRpZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5vcGFjaXR5LnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc29sdXRpb246IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZS5jb3B5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNpemVBdHRlbnVhdGlvbjoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2l6ZUF0dGVudWF0aW9uLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLnNpemVBdHRlbnVhdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGFzaEFycmF5OiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kYXNoQXJyYXkudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMuZGFzaEFycmF5LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy51c2VEYXNoID0gdmFsdWUgIT09IDAgPyAxIDogMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhc2hPZmZzZXQ6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRhc2hPZmZzZXQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMuZGFzaE9mZnNldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGFzaFJhdGlvOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kYXNoUmF0aW8udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMuZGFzaFJhdGlvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEYXNoOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51c2VEYXNoLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVzZURhc2gudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZUdyYWRpZW50OiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51c2VHcmFkaWVudC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy51c2VHcmFkaWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudmlzaWJpbGl0eS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy52aXNpYmlsaXR5LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbHBoYVRlc3Q6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmFscGhhVGVzdC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5hbHBoYVRlc3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcGVhdDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucmVwZWF0LnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLnJlcGVhdC52YWx1ZS5jb3B5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuICB9XG4gIGNvcHkoc291cmNlKSB7XG4gICAgc3VwZXIuY29weShzb3VyY2UpO1xuICAgIHRoaXMubGluZVdpZHRoID0gc291cmNlLmxpbmVXaWR0aDtcbiAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG4gICAgdGhpcy51c2VNYXAgPSBzb3VyY2UudXNlTWFwO1xuICAgIHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG4gICAgdGhpcy51c2VBbHBoYU1hcCA9IHNvdXJjZS51c2VBbHBoYU1hcDtcbiAgICB0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcbiAgICB0aGlzLmdyYWRpZW50ID0gc291cmNlLmdyYWRpZW50O1xuICAgIHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xuICAgIHRoaXMucmVzb2x1dGlvbi5jb3B5KHNvdXJjZS5yZXNvbHV0aW9uKTtcbiAgICB0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG4gICAgdGhpcy5kYXNoQXJyYXkgPSBzb3VyY2UuZGFzaEFycmF5O1xuICAgIHRoaXMuZGFzaE9mZnNldCA9IHNvdXJjZS5kYXNoT2Zmc2V0O1xuICAgIHRoaXMuZGFzaFJhdGlvID0gc291cmNlLmRhc2hSYXRpbztcbiAgICB0aGlzLnVzZURhc2ggPSBzb3VyY2UudXNlRGFzaDtcbiAgICB0aGlzLnVzZUdyYWRpZW50ID0gc291cmNlLnVzZUdyYWRpZW50O1xuICAgIHRoaXMudmlzaWJpbGl0eSA9IHNvdXJjZS52aXNpYmlsaXR5O1xuICAgIHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcbiAgICB0aGlzLnJlcGVhdC5jb3B5KHNvdXJjZS5yZXBlYXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiByYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICBjb25zdCBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuTWF0cml4NCgpO1xuICBjb25zdCByYXkgPSBuZXcgVEhSRUVfX25hbWVzcGFjZS5SYXkoKTtcbiAgY29uc3Qgc3BoZXJlID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuU3BoZXJlKCk7XG4gIGNvbnN0IGludGVyUmF5ID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMygpO1xuICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gIHNwaGVyZS5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKTtcbiAgc3BoZXJlLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgaWYgKCFyYXljYXN0ZXIucmF5LmludGVyc2VjdFNwaGVyZShzcGhlcmUsIGludGVyUmF5KSlcbiAgICByZXR1cm47XG4gIGludmVyc2VNYXRyaXguY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgcmF5LmNvcHkocmF5Y2FzdGVyLnJheSkuYXBwbHlNYXRyaXg0KGludmVyc2VNYXRyaXgpO1xuICBjb25zdCB2U3RhcnQgPSBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKCk7XG4gIGNvbnN0IHZFbmQgPSBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKCk7XG4gIGNvbnN0IGludGVyU2VnbWVudCA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjMoKTtcbiAgY29uc3Qgc3RlcCA9IHRoaXMgaW5zdGFuY2VvZiBUSFJFRV9fbmFtZXNwYWNlLkxpbmVTZWdtZW50cyA/IDIgOiAxO1xuICBjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICBjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgY29uc3Qgd2lkdGhzID0gYXR0cmlidXRlcy53aWR0aC5hcnJheTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3QgYSA9IGluZGljZXNbaV07XG4gICAgICBjb25zdCBiID0gaW5kaWNlc1tpICsgMV07XG4gICAgICB2U3RhcnQuZnJvbUFycmF5KHBvc2l0aW9ucywgYSAqIDMpO1xuICAgICAgdkVuZC5mcm9tQXJyYXkocG9zaXRpb25zLCBiICogMyk7XG4gICAgICBjb25zdCB3aWR0aCA9IHdpZHRoc1tNYXRoLmZsb29yKGkgLyAzKV0gIT0gdm9pZCAwID8gd2lkdGhzW01hdGguZmxvb3IoaSAvIDMpXSA6IDE7XG4gICAgICBjb25zdCBwcmVjaXNpb24gPSByYXljYXN0ZXIucGFyYW1zLkxpbmUudGhyZXNob2xkICsgdGhpcy5tYXRlcmlhbC5saW5lV2lkdGggKiB3aWR0aCAvIDI7XG4gICAgICBjb25zdCBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcbiAgICAgIGNvbnN0IGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCk7XG4gICAgICBpZiAoZGlzdFNxID4gcHJlY2lzaW9uU3EpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaW50ZXJSYXkuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGludGVyUmF5KTtcbiAgICAgIGlmIChkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhcilcbiAgICAgICAgY29udGludWU7XG4gICAgICBpbnRlcnNlY3RzLnB1c2goe1xuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgIGZhY2VJbmRleDogdm9pZCAwLFxuICAgICAgICBvYmplY3Q6IHRoaXNcbiAgICAgIH0pO1xuICAgICAgaSA9IGw7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLk1lc2hMaW5lR2VvbWV0cnkgPSBNZXNoTGluZUdlb21ldHJ5O1xuZXhwb3J0cy5NZXNoTGluZU1hdGVyaWFsID0gTWVzaExpbmVNYXRlcmlhbDtcbmV4cG9ydHMucmF5Y2FzdCA9IHJheWNhc3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/meshline/dist/index.cjs\n");

/***/ })

};
;